== Statements and clauses

Each statement is built from a sequence of _clauses_. The beginning of a clause is identified by a keyword: `from`, `where`, `group`, `having`, `select`, `set`, or `order`.

=== Clauses

As discussed in <<algebra>>, there is a logical ordering of clauses, reflecting the order in which their effect must be computed by the datastore:

1. <<from-clause,`from`>>,
2. <<where-clause,`where`>>,
3. <<group-clause,`#group#`>>,
4. <<having-clause,`#having#`>>,
5. <<select-clause,`select`>> or <<set-clause,`set`>>,
6. <<order-clause,`order`>>.

The interpretation and effect of each clause in this list is influenced by clauses occurring earlier in the list, but not by clauses occurring later in the list.

[[from-clause]]
==== From clause

In the core language, the `from` clause, with syntax given by `from_clause`, specifies an _entity name_ identifying the root entity of the query, as defined in <<root-entity>>.
This entity is always assigned the implicit alias `this`.

In the core language, path expressions occurring in later clauses are interpreted with respect to this entity. That is, the first element of each path expression in the query must be a persistent attribute of the entity named in the `from` clause. The entity name is a Java identifier, usually the unqualified name of the entity class, as specified in <<entities-and-embeddables>>.

NOTE: The core language does not have joins, and so the `from` clause is always trivial.

In the extended language, the `from` clause might enumerate multiple steps of the basic operation pipeline.
The `#from_clause#` of the full grammar allows:

1. A root entity, as defined in <<root-entity>>, which may either:
   - explicitly specify its alias according to the syntax given by `#range_variable_declaration#`, or
   - let the alias default to `this`, by using the syntax given by `#this_implicit_variable#`.
2. Optionally, a list of additional ``#range_variable_declaration#``s interpreted as <<joins-entities,joins to named entities>>.
3. Optionally, one or more join clauses, as defined in <<joins>>, with syntax given by `#join#`, each interpreted as a join to a named entity or as a <<joins-nested,join to a nested structure or collection>>, which may each optionally also contain a restriction with syntax given by `#join_condition#`.

When the root entity is declared using the rule `#this_implicit_variable#`, the query must not have joins.
A query with joins must use an `#identification_variable_declarations#` list to specify the root entity and joins.

When a `from` clause has multiple elements in the  `#identification_variable_declarations#` list, the root entity is always the first `#identification_variable_declaration#` to occur in the list.
Each subsequent `#identification_variable_declaration#` is considered a <<joins-entities,join to a named entity>>.
Join clauses are discussed <<join-clauses,below>>.

An `#identification_variable_declaration#` declaring a root entity has a `#range_variable_declaration#` with an `#entity_name#` specifying the name of the root entity, and an `#identification_variable#` specifying its alias (label).

Since a `from` clause may introduce multiple distinct labels, paths in the extended language may begin with the label of an entity.
Alternatively, a path which does not begin with the label of an entity is interpreted as beginning with the implicit label `this`.

// NOTE: The syntax of the `update` statement is irregular, with the `from` keyword implied. That is, the syntax _should_ be `update from Entity`, but for historical reasons it is simply `update Entity`.

The `from` clause is optional in `select` statements when a mechanism from an external specification is used to identify the queried entity. For example:

1. a result type might be supplied via an API invocation (for example, via `createQuery()` in Jakarta Persistence), or
2. it might be determined by static analysis (for example, in Jakarta Data, by the return type of a repository method or by the primary entity type of the repository).

For example, this query provided to the Jakarta Persistence `createQuery()` method with result type of `Book.class` or supplied to a Jakarta Data repository method that returns `List<Book>`:

[source,sql]
----
where title like :title
----

is equivalent to:

[source,sql]
----
from Book where title like :title
----

[[join-clauses]]
==== Join clauses

In the extended language, an `#identification_variable_declaration#` might include a list of:

- joins, with syntax given by `#join#` and semantics specified by <<joins>>, and
- fetch joins, with syntax given by `#fetch_join#` and semantics specified by <<fetch-joins>>.

Each `#join#` is in turn either a `#range_join#`, with semantics given by <<joins-entities>> or a `#path_join#`, with semantics given by <<joins-nested>>.
Such joins may specify a restriction.

In addition, each `#identification_variable_declaration#` apart from the first -- which specifies the root entity -- is itself considered a join.
Every such `#identification_variable_declaration#` is interpreted as a regular (inner) join and never specifies a restriction.

Every join has a _target_, either a named entity type belonging to the database, or a path to a nested structure or collection in the result list of the previous operation in the pipeline:

- A `#range_join#` or `#identification_variable_declaration#` has a `#range_variable_declaration#` with an `#entity_name#` specifying the name of the joined entity.

- A `#path_join#` has a `#join_association_expression#` specifying the joined nested structure or collection.

In either case, a `#join_condition#` may occur, specifying a restriction which is applied to the result list of the join.

A `#range_join#` or `#identification_variable_declaration#` has a `#range_variable_declaration#` with an `#identification_variable#`.
Similarly, a `#path_join#` has a `#identification_variable#`.
The `#identification_variable#` specifies the alias (label) introduced by the join.

Every `#join#` or `#fetch_join#` begins with a `#join_spec#`:

- if the keyword `#left#` occurs in the `#join_spec#`, then the join is interpreted as a left (outer) join, as specified by <<left-joins>>, or
- otherwise, if the keyword `#left#` is missing, the join is interpreted as a regular (inner) join.

The joins belonging to a query are evaluated in the order in which they occur in the query.

[[where-clause]]
==== Where clause

The `where` clause, with syntax given by `where_clause`, specifies a restriction on a result list, as specified by <<restriction>>.

The `where` clause specifies a `conditional_expression`, interpreted as the logical predicate of the restriction.

A restriction specified using `where` is applied after every join and before any aggregation or projection.

// The `where` clause, with syntax given by `where_clause`, specifies a conditional expression used to restrict the records returned, deleted, or updated by the query. Only records for which the conditional expression is satisfied are returned, deleted, or updated.
//
// The `where` clause is always optional. When it is missing, there is no restriction, and all records of the queried entity type are returned, deleted, or updated.

[[group-clause]]
==== Group clause

The `#group#` clause in the extended language, with syntax given by `#groupby_clause#`, specifies a list of grouping items, which are collectively interpreted as an aggregation, as specified in <<aggregation>>.

According to the rule `#groupby_item#`, each item must be either:

- an atomic-valued path expression, with syntax given by `#atomic_valued_path_expression#`, or
- an entity-valued path expression, with syntax given by `#entity_valued_path_expression#`.

Each such path expression is interpreted as a value expression producing an element of the grouping tuple of the aggregation.

NOTE: An implementation of Jakarta Query might treat the entity-valued path expression as an expression referring to the identifier of the entity.

[[having-clause]]
==== Having clause

The `#having#` clause in the extended language, with syntax given by `#having_clause#`, specifies a restriction on the result list of an aggregation, as specified by <<restriction>>.

The `#having#` clause specifies a `conditional_expression`, interpreted as the logical predicate of the restriction.

The `#having#` clause must follow a `#group#` clause.
A query with no group clause may not have a having clause.
A restriction specified using `having` is applied after aggregation and before any projection.

[[select-clause]]
==== Select clause

In the core language, the `select` clause, with syntax given by `select_clause`, specifies one or more path expressions with syntax `simple_path_expression`, which are collectively interpreted as a projection with automatically assigned aliases, as specified in <<projection>>.

Alternatively, the `select` clause may contain either:

- a single `count(this)` <<aggregate-functions,aggregate function invocation>>, or
- a single <<identifier-version-expressions,identifier expression>>.

A query beginning with `select count(this)` performs aggregation (without grouping), as specified by <<projection-and-aggregation>> and always returns a result list of unit length.

// NOTE: If a datastore does not natively provide the ability to count query results, the Jakarta Query provider is strongly encouraged, but not required, to implement this operation by counting the query results in Java.

[WARNING]
====
When a Jakarta Query implementation targets a non-relational database, support for projection might vary from what is described above.
In particular, this specification does not require support for `count(this)` if the underlying datastore only provides for key-based lookups.
====

In the extended language, the `select` clause is much more flexible.
Its syntax, given by `#select_clause#`, permits:

- one or more expressions, with optional labels, as given by `#select_item#`, where `#select_expression#` is the expression, and `#result_variable#` is the label, and
- optionally, the `#distinct#` keyword.

The list of expressions is interpreted as a projection, as specified by <<projection>>, and, if at least one of the expressions is an <<aggregate-functions,aggregate function>>, also aggregation, as specified in <<projection-and-aggregation>>.

If the `#distinct#` keyword occurs, then projection is followed by duplicate elimination, as specified by <<distinct>>.

[[set-clause]]
==== Set clause

The `set` clause, with syntax given by `set_clause`, specifies a list of updates to attributes of the queried entity. For each record satisfying the restriction imposed by the `where` clause, and for each element of the list, the scalar expression is evaluated and assigned to the entity attribute identified by the path expression.

[[order-clause]]
==== Order clause

The `order` clause (or `order by` clause), with syntax given by `orderby_clause`, specifies a lexicographic order for the query results, that is, a list of expressions used to sort the records which satisfy the restriction imposed by the `where` clause, as specified in <<ordering>>.

An item of the order by clause, with syntax given by `orderby_item` has:

- an `orderby_expression`, which must be an expression assigned an atomic type, and
- optionally, the keyword `asc` or `desc`,
- optionally, in the extended language, `#nulls first#` or `#nulls last#`.

In the core language, an `orderby_expression` must be a <<path-expressions,path expression>> or <<identifier-version-expressions,identifier expression>>.
In the extended language, an `orderby_expression` may be almost any sort of atomic-valued expression (but not a parameter), as specified by the full grammar of the extended language.

NOTE: An implementation of Jakarta Query is not required to support sorting by any expression not <<projection,returned by the query>>. If a query returns an entity, then any sortable attribute of the queried entity may occur in the `order` clause. Otherwise, if the query has an explicit `select` clause, an implementation might require that an attribute which occurs in the `order` also occurs in the `select`.

The keyword `asc` or `desc` specifies that the values of a given expression should be sorted in ascending or descending order respectively; when neither is specified, ascending order is the default:

- _ascending order_ is determined by the natural order of the expression type, as specified by <<natural-order>>, and
- _descending order_ is the reverse of the natural order.

Entity attributes occurring earlier in the `order by` clause take precedence. That is, an attribute occurring later in the `order by` clause is only used to resolve "ties" between records which cannot be unambiguously ordered using only earlier attributes.

In the extended language, `#nulls first#` or `#nulls last#` specifies whether null values should be considered, respectively, smaller or larger than non-null values. This specification does not define how null values are ordered with respect to non-null values when the sorting of null values is not explicitly specified. The ordering of null values may vary between data stores and between Jakarta Query providers.

The `order` clause is always optional. When it is missing, the order of the query results is not defined by this specification and might not be deterministic.

NOTE: An implementation of Jakarta Query might provide some other facility to specify sorting criteria for the results of a given query. For example, Jakarta Query allows an object carrying sorting criteria to be passed as an argument to a repository method.

[WARNING]
====
When a Jakarta Query implementation targets a non-relational database, support for sorting query results might vary from what is described above.
This specification does not require support for sorting a query result list according to a given ordering if the underlying datastore does not provide a way to sort query results according to that ordering via its native querying capabilities.
====

NOTE: If a datastore does not natively provide the ability to sort query results, the Jakarta Query provider is strongly encouraged, but not required, to sort the query results in Java before returning the results to the client.

[[union-intersect-except]]
=== Union, intersect, and except

The semantics of union, intersection, and complementation of query result sets is specified by <<union-intersection>> above.

NOTE: These operations are part of the extended language, and so support for union, intersection, and complementation is not required for an implementation of Jakarta Query core.

Each of these operations is treated as an infix binary operator acting on query result lists of identical shape (type) and producing a new query result set of the same shape as the operands.

==== Union and complement

The syntax of `#union#`, `#union all#`, `#except#`, and `#except all#` is given by the rule `#union#` of the full grammar.
The operands must produce result lists of the same type.
The type of the union or complement expression is the same as the type of its operands.

==== Intersection

The syntax of `#intersect#` and `#intersect all#` is given by the rule `#intersection#` of the full grammar.
The operands must produce result lists of the same type.
The type of the intersection expression is the same as the type of its operands.

=== Statements

Finally, there are three kinds of _statement_:

- `select` statements,
- `update` statements, and
- `delete` statements.

The clauses which can appear in a statement are given by the grammar for each kind of statement.

==== Select statements

A `select` statement, with syntax given by `select_statement`, returns data to the client.

In the core language, a `select` statement may contain one of more of the following clauses:

- `select`
- `from`
- `where`
- `order`.

A `select` statement is a pipeline as defined in <<algebra>>.
The result list of the whole `select` statement is the same as the result list of the last operation in the pipeline.

In the extended language, a `select` statement may contain, in addition, a `#group#` and/or a `#having#` clause, with syntax specified by `#select_query#`.
Each `#select_query#` is a pipeline as defined in <<algebra>>.
A `#select_statement#` in the full grammar may contain union, intersection, and complement operations, as defined in <<union-intersect-except>>.

- If the `#select_statement#` is a `#union#` or `#intersection#`, the result list of the whole `select` statement is the same as the result list of the union or intersection.
- Otherwise, if the `#select_statement#` is just a `#select_query#`, result list of the whole `select` statement is the same as the result list of the last operation in the pipeline.

The `select` clause is optional in a `select` statement.
A query with a missing `select` clause is interpreted as if it had the following single-item `select` clause:
[source,sql]
----
select this
----
where `this` is the implicit alias.

==== Update statements

An `update` statement, with syntax given by `update_statement`, updates each record belonging to the entity type named in the `update` clause which satisfies the restriction imposed by the `where` clause, if any.

An `update` statement does not have a well-defined result, but implementations typically return the number of matching records to the client.
Such functionality falls outside the scope of this specification.

[WARNING]
====
A Jakarta Query implementation which targets a non-relational database might not support conditional updates.
This specification does not require support for conditional updates if the underlying datastore does not provide a functionally equivalent capability.footnote:[Alternatively, in a non-relational database with _append-only semantics_ -- common in time-series and wide-column databases -- conditional updates might be provided, but the update operation might behave more like an insert operation, with repeated updates to the same record not overwriting previous values.]
====

==== Delete statements

A `delete` statement, with syntax given by `delete_statement`, deletes each record  belonging to the entity type named in the `update` clause which satisfies the restriction imposed by the `where` clause, if any.

A `delete` statement does not have a well-defined result, but implementations typically return the number of deleted records to the client.
Such functionality falls outside the scope of this specification.

[WARNING]
====
A Jakarta Query implementation which targets a non-relational database might not support conditional deletes.
This specification does not require support for conditional deletes if the underlying datastore does not provide a functionally equivalent capability.
====

