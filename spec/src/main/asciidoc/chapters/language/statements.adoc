== Statements and clauses

Each statement is built from a sequence of _clauses_. The beginning of a clause is identified by a keyword: `from`, `where`, `group`, `having`, `select`, `set`, or `order`.

=== Clauses

As discussed in <<algebra>>, there is a logical ordering of clauses, reflecting the order in which their effect must be computed by the datastore:

1. `from`
2. `where`,
3. `#group#`
4. `#having#`,
5. `select` or `set`,
6. `order`.

The interpretation and effect of each clause in this list is influenced by clauses occurring earlier in the list, but not by clauses occurring later in the list.

==== From clause

In the core language, the `from` clause, with syntax given by `from_clause`, specifies an _entity name_ identifying the root entity of the query, as defined in <<root-entity>>.
This entity is always assigned the implicit alias `this`.

In the core language, path expressions occurring in later clauses are interpreted with respect to this entity. That is, the first element of each path expression in the query must be a persistent attribute of the entity named in the `from` clause. The entity name is a Java identifier, usually the unqualified name of the entity class, as specified in <<entities-embeddables>>.

NOTE: The core language does not have joins, and so the `from` clause is always trivial.

In the extended language, the `from` clause might enumerate multiple steps of the basic operation pipeline.
The `#from_clause#` of the full grammar allows:

1. A root entity, as defined in <<root-entity>>, which may either:
   - explicitly specify its alias according to the syntax given by `#range_variable_declaration#`, or
   - let the alias default to `this`, by using the syntax given by `#this_implicit_variable#`.
2. Optionally, a list of additional ``#range_variable_declaration#``s interpreted as <<joins-entities,joins to named entities>>.
3. Optionally, one or more join clauses, as defined in <<joins>>, with syntax given by `#join#`, each interpreted as a join to a named entity or as a <<joins-nested,join to a nested structure or collection>>, which may each optionally also contain a restriction with syntax given by `#join_condition#`.

When the root entity is declared using the rule `#this_implicit_variable#`, the query may not have joins.
A query with joins must use an `#identification_variable_declarations#` list to specify the root entity and joins.

When a `from` clause has multiple elements in the  `#identification_variable_declarations#` list, the root entity is always the first `#identification_variable_declaration#` to occur in the list.
Each subsequent `#identification_variable_declaration#` is considered a <<joins-entities,join to a named entity>>.
Join clauses are discussed <<join-clauses,below>>.

An `#identification_variable_declaration#` declaring a root entity has a `#range_variable_declaration#` with an `#entity_name#` specifying the name of the root entity, and an `#identification_variable#` specifying its alias (label).

Since a `from` clause may introduce multiple distinct labels, paths in the extended language may begin with the label of an entity.
Alternatively, a path which does not begin with the label of an entity is interpreted as beginning with the implicit label `this`.

// NOTE: The syntax of the `update` statement is irregular, with the `from` keyword implied. That is, the syntax _should_ be `update from Entity`, but for historical reasons it is simply `update Entity`.

The `from` clause is optional in `select` statements when a mechanism from an external specification is used to identify the queried entity. For example:

1. a result type might be supplied via an API invocation (for example, via `createQuery()` in Jakarta Persistence), or
2. it might be determined by static analysis (for example, in Jakarta Data, by the return type of a repository method or by the primary entity type of the repository).

For example, this query provided to the Jakarta Persistence `createQuery()` method with result type of `Book.class` or supplied to a Jakarta Data repository method that returns `List<Book>`:

[source,sql]
----
where title like :title
----

is equivalent to:

[source,sql]
----
from Book where title like :title
----

[[join-clauses]]
==== Join clauses

In the extended language, an `#identification_variable_declaration#` might include a list of:

- joins, with syntax given by `#join#` and semantics specified by <<joins>>, and
- fetch joins, with syntax given by `#fetch_join#` and semantics specified by <<fetch-joins>>.

Each `#join#` is in turn either a `#range_join#`, with semantics given by <<joins-entities>> or a `#path_join#`, with semantics given by <<joins-nested>>.
Such joins may specify a restriction.

In addition, each `#identification_variable_declaration#` apart from the first -- which specifies the root entity -- is itself considered a join.
Every such `#identification_variable_declaration#` is interpreted as a regular (inner) join and never specifies a restriction.

Every join has a _target_, either a named entity type belonging to the database, or a path to a nested structure or collection in the result list of the previous operation in the pipeline:

- A `#range_join#` or `#identification_variable_declaration#` has a `#range_variable_declaration#` with an `#entity_name#` specifying the name of the joined entity.

- A `#path_join#` has a `#join_association_expression#` specifying the joined nested structure or collection.

In either case, a `#join_condition#` may occur, specifying a restriction which is applied to the result list of the join.

A `#range_join#` or `#identification_variable_declaration#` has a `#range_variable_declaration#` with an `#identification_variable#`.
Similarly, a `#path_join#` has a `#identification_variable#`.
The `#identification_variable#` specifies the alias (label) introduced by the join.

Every `#join#` or `#fetch_join#` begins with a `#join_spec#`:

- if the keyword `#left#` occurs in the `#join_spec#`, then the join is interpreted as a left (outer) join, as specified by <<left-joins>>, or
- otherwise, if the keyword `#left#` is missing, the join is interpreted as a regular (inner) join.

The joins belonging to a query are evaluated in the order in which they occur in the query.

==== Where clause

The `where` clause, with syntax given by `#here_clause`, specifies a restriction on a result list, as specified by <<restriction>>.

The `where` clause specifies a `conditional_expression`, interpreted as the logical predicate of the restriction.

A restriction specified using `where` is applied after every join and before any aggregation or projection.

// The `where` clause, with syntax given by `where_clause`, specifies a conditional expression used to restrict the records returned, deleted, or updated by the query. Only records for which the conditional expression is satisfied are returned, deleted, or updated.
//
// The `where` clause is always optional. When it is missing, there is no restriction, and all records of the queried entity type are returned, deleted, or updated.

==== Group clause

The `#group#` clause in the extended language, with syntax given by `#groupby_clause#`, specifies a list of grouping items, which are collectively interpreted as an aggregation, as specified in <<aggregation>>.

According to the rule `#groupby_item#`, each item must be either:

- an atomic-valued path expression, with syntax given by `#atomic_valued_path_expression#`, or
- an entity-valued path expression, with syntax given by `#entity_valued_path_expression#`.

Each such path expression is interpreted as a value expression producing an element of the grouping tuple of the aggregation.

NOTE: An implementation of Jakarta Query might treat the entity-valued path expression as an expression referring to the identifier of the entity.

==== Having clause

The `#having#` clause in the extended language, with syntax given by `#having_clause#`, specifies a restriction on the result list of an aggregation, as specified by <<restriction>>.

The `#having#` clause specifies a `conditional_expression`, interpreted as the logical predicate of the restriction.

The `#having#` clause must follow a `#group#` clause.
A query with no group clause may not have a having clause.
A restriction specified using `having` is applied after aggregation and before any projection.

==== Select clause

In the core language, the `select` clause, with syntax given by `select_clause`, specifies one or more path expressions with syntax `simple_path_expression`, which are collectively interpreted as a projection with automatically assigned aliases, as specified in <<projection>>.

Alternatively, the `select` clause may contain either:

- a single `count(this)` <<aggregate-functions,aggregate function invocation>>, or
- a single <<Identifier expressions,identifier expression>>.

A query beginning with `select count(this)` performs aggregation (without grouping), as specified by <<projection-and-aggregation>> and always returns a result list of unit length.

// NOTE: If a datastore does not natively provide the ability to count query results, the Jakarta Query provider is strongly encouraged, but not required, to implement this operation by counting the query results in Java.

[WARNING]
====
When working with NoSQL databases, the `select` clause behavior may vary depending on the database structure and capabilities:

Key-value databases:: These databases generally do not support `select` clauses beyond retrieving values by their keys. Support for complex path expressions and aggregate functions like `count(this)` is not required.

Wide-column databases:: The ability to use a `select` clause may depend on the presence of secondary indexes. Without secondary indexes, selection is often restricted to key-based operations. Support for `count(this)` is not required.

Graph and document databases:: Support for flexible `select` clauses, including path expressions and aggregate functions like `count(this)` is required. Performance might vary based on the size and indexing of the dataset.
====

In the extended language, the `select` clause is much more flexible.
Its syntax, given by `#select_clause#`, permits:

- one or more expressions, with optional labels, as given by `#select_item#`, where `#select_expression#` is the expression, and `#result_variable#` is the label, and
- optionally, the `#distinct#` keyword.

The list of expressions is interpreted as a projection, as specified by <<projection>>, and, if at least one of the expressions is an <<aggregate-functions,aggregate function>>, also aggregation, as specified in <<projection-and-aggregation>>.

If the `#distinct#` keyword occurs, then projection is followed by duplicate elimination, as specified by <<distinct>>.

==== Set clause

The `set` clause, with syntax given by `set_clause`, specifies a list of updates to attributes of the queried entity. For each record which satisfies the restriction imposed by the `where` clause, and for each element of the list, the scalar expression is evaluated and assigned to the entity attribute identified by the path expression.

==== Order clause

The `order` clause (or `order by` clause), with syntax given by `orderby_clause`, specifies a lexicographic order for the query results, that is, a list of entity attributes used to sort the records which satisfy the restriction imposed by the `where` clause. The keywords `asc` and `desc` specify that a given attribute should be sorted in ascending or descending order respectively; when neither is specified, ascending order is the default.

NOTE: An implementation of Jakarta Query is not required to support sorting by entity attributes which are not returned by the query. If a query returns the queried entity, then any sortable attribute of the queried entity may occur in the `order` clause. Otherwise, if the query has an explicit `select` clause, a provider might require that an attribute which occurs in the `order` also occurs in the `select`.

Entity attributes occurring earlier in the `order by` clause take precedence. That is, an attribute occurring later in the `order by` clause is only used to resolve "ties" between records which cannot be unambiguously ordered using only earlier attributes.

This specification does not define how null values are ordered with respect to non-null values. The ordering of null values may vary between data stores and between Jakarta Query providers.

The `order` clause is always optional. When it is missing, the order of the query results is not defined by this specification and might not be deterministic.

NOTE: An implementation of Jakarta Query might provide some other facility to specify sorting criteria for the results of a given query. For example, Jakarta Query allows an object carrying sorting criteria to be passed as an argument to a repository method.

NOTE: If a datastore does not natively provide the ability to sort query results, the Jakarta Query provider is strongly encouraged, but not required, to sort the query results in Java before returning the results to the client.

[[union-intersect-except]]
=== Union, intersect, and except

The semantics of union, intersection, and complementation of query result sets is specified by <<union-intersection>> above.

NOTE: These operations are part of the extended language, and so support for union, intersection, and complementation is not required for an implementation of Jakarta Query core.

Each of these operations is treated as an infix binary operator acting on query result lists of identical shape (type), and producing a new query result set of the same shape as the operands.

==== Union and complement

The syntax of `#union#`, `#union all#`, `#except#`, and `#except all#` is given by the rule `#union#` of the full grammar.
The operands must produce result lists of the same type.
The type of the union or complement expression is the same as the type of its operands.

==== Intersection

The syntax of `#intersect#` and `#intersect all#` is given by the rule `#intersection#` of the full grammar.
The operands must produce result lists of the same type.
The type of the interaction expression is the same as the type of its operands.

=== Statements

Finally, there are three kinds of _statement_:

- `select` statements,
- `update` statements, and
- `delete` statements.

The clauses which can appear in a statement are given by the grammar for each kind of statement.

==== Select statements

A `select` statement, with syntax given by `select_statement`, returns data to the client.

In the core language, a `select` statement may contain one of more of the following clauses:

- `select`
- `from`
- `where`
- `order`.

A `select` statement is a pipeline as defined in <<algebra>>.
The result list of the whole `select` statement is the same as the result list of the last operation in the pipeline.

In the extended language, a `select` statement may contain, in addition, a `#group#` and/or a `#having#` clause, with syntax specified by `#select_query#`.
Each `#select_query#` is a pipeline as defined in <<algebra>>.
A `#select_statement#` in the full grammar may contain union, intersection, and complement operations, as defined in <<union-intersect-except>>.

- If the `#select_statement#` is a `#union#` or `#intersection#`, the result list of the whole `select` statement is the same as the result list of the union or intersection.
- Otherwise, if the `#select_statement#` is just a `#select_query#`, result list of the whole `select` statement is the same as the result list of the last operation in the pipeline.

The `select` clause is optional in a `select` statement.
A query with a missing `select` clause is interpreted as if it had the following single-item `select` clause:
[sourrce,sql]
----
select this
----
where `this` is the implicit alias.

==== Update statements

An `update` statement, with syntax given by `update_statement`, updates each record belonging to the entity type named in the `update` clause which satisfies the restriction imposed by the `where` clause, if any.

An `update` statement does not have a well-defined result, but implementations typically return the number of deleted records to the client.
Such functionality falls outside the scope of this specification.

[WARNING]
====
A NoSQL database might not be capable of conditional updates or might not be able to determine the number of matching records reliably for an `update` operation that returns an `int` or `long`.

Additionally, in databases with **append-only semantics**—such as many time-series and wide-column databases—the `update` operation may behave more like an `insert`, and repeated updates to the same record might not overwrite previous values.
====

==== Delete statements

A `delete` statement, with syntax given by `delete_statement`, deletes each record  belonging to the entity type named in the `update` clause which satisfies the restriction imposed by the `where` clause, if any.

A `delete` statement does not have a well-defined result, but implementations typically return the number of deleted records to the client.
Such functionality falls outside the scope of this specification.

[WARNING]
====
A NoSQL database might not be capable of the execution of conditional deletes or might not be able to determine the number of deleted records reliably for a `delete` operation.
====

