== Expressions

[[value-expressions]]
=== Value expressions

An expression is a sequence of tokens to which a type can be assigned, and which evaluates to a well-defined value when the query is executed.
Expressions may be categorized as:

- <<literal-expressions,literal atomic values>>, <<enum-literals,enum literals>>, and <<special-values,special values>>,
- <<parameters,parameters>>,
- <<path-expressions,paths>>,
- <<function-calls,function calls>> and <<aggregate-functions,aggregate function calls>>,
- <<types-and-typecasts,typecasts>>, <<entity-type-expressions,type expressions>>, and <<entity-type-literals,literal entity types>>,
- <<case-expressions,case expressions>>,
- <<operator-expressions,operator expressions>>, and
- <<subquery-expressions>>.

[[literal-expressions]]
==== Literal expressions

The syntax for literal expressions is given by the rules `string_literal` and `numeric_literal`, and in the previous section titled <<Lexical structure>>.

In an implementation for Java, a string, integer, or decimal literal is assigned the type it would be assigned in Java.
So, for example, `'Hello'` is assigned the type `java.lang.String`, `123` is assigned the type `int`, `1e4` is assigned the type `double`, and `1.23f` is assigned the type `float`.
In the extended language:

- arbitrary-precision integer literals (with suffix `BI`) are assigned the type `java.math.BigInteger`, and
- arbitrary-precision decimal literals (with suffix `BD`) are assigned the type `java.math.BigDecimal`.

When executed, a literal expression evaluates to its literal value.

[[special-values]]
==== Special values

The syntax for _special values_ is given by the rules `special_boolean_expression` and `special_datetime_expression`.

In an implementation of Jakarta Query for Java:

- the special values `true` and `false` are assigned the type `boolean`, and
- the special values `local date`, `local time`, and `local datetime` are assigned the types `java.time.LocalDate`, `java.time.LocalTime`, and `java.time.LocalDateTime`.

The expression `true` and `false` evaluate to their literal values.
The expressions `local date`, `local time`, and `local datetime` evaluate to the current date, current time, and current datetime of the database server, respectively.

[[parameters]]
==== Parameter expressions

A _parameter expression_, with syntax given by `input_parameter`, is assigned a type and value either:

1. at runtime, via invocation of some API (for example, `setParameter()` in Jakarta Persistence), or
2. at compile type, via static analysis (for example, by inspecting the parameters of a Jakarta Data repository method).

NOTE: This specification does not define how arguments are assigned to parameter expressions.

When executed, a parameter expression evaluates to the argument assigned to the parameter.

Positional and named parameters must not be mixed in a single query.

[[enum-literals]]
==== Enum literals

An _enum literal expression_ is a sequence of identifiers, with syntax specified by `enum_literal`, and must refer to a member of some sort of enumerated type.
An enum literal may only occur as:

- the right operand of an `update_item` belonging to a `set` assignment,
- the right operand of an `=` or `<>` equality comparison, or
- an `in_item` element of an `in_item_list` occurring as the right operand of the <<in-expressions,`in` operator>>.

In each case, the enum literal expression is assigned the type of the left operand of the assignment, comparison, or `in` operator.

In an implementation for Java, the type assigned must be a Java `enum` type, and the identifier must be the name of an enumerated value of the `enum` type including the fully qualified Java enum class name. For example, `day <> java.time.DayOfWeek.MONDAY` is a legal comparison expression.

When executed, the enum literal expression evaluates to the named member of the enumerated type.

**TODO** allow `day <> MONDAY`, since the `enum` type can be inferred.

[[entity-type-literals]]
==== Entity type literals

In the extended language, an _entity type literal_, with syntax given by `#entity_type_literal#` is just the name of an entity type, in the sense given in <<entities-and-embeddables>>.
When executed, it evaluates to a value which represents the named entity type.

An implementation for Java assigns the type `java.lang.Class<E>` to an entity type literal, where `E` is the Java class mapping the named entity type.
When executed, the literal evaluates to an instance of `Class` representing the Java class `E`.

[[path-expressions]]
==== Path expressions

A _path expression_ is a period-separated list of Java identifiers, with syntax specified by `state_field_path_expression`. A path expression is a compound path identifying an element of a structure, as discussed above in <<paths>>. Each identifier is interpreted as the name of an attribute of an entity or embeddable type. Each prefix of the list is assigned a type:

- the first element of the list is assigned the type of the named attribute of the entity being queried, and
- each subsequent element is assigned the type of the named attribute of the type assigned to the previous element.

The type of the whole path expression is the type of the last element of the list. For example, `pages` might be assigned the type `int`, `address` might be assigned the type `org.example.Address`, and `address.street` might be assigned the type `java.lang.String`.

NOTE: Typically, the last element of a path expression is assigned an <<atomic-values,atomic value type>>. Non-terminal path elements are assigned a <<structures-and-records,structure type>>, usually an embeddable type, if the element references an embeddable, or an entity type, if the element references an association. Jakarta EE specifications that use Jakarta Query determine whether a provider is required to support embedded attributes or associations, which require support for compound path expressions.

When a path expression is executed, each element of the path is evaluated in turn:

- the first element of the path expression is evaluated in the context of a given record of the queried entity type, and evaluates to the value of the named entity attribute of the given record, and then
- each subsequent element is evaluated in the context of the result produced the previous element (typically, and embeddable class or associated entity class), and evaluates to the value of the named attribute of the result.

If any element of a path expression evaluates to a null value, the whole path expression evaluates to a null value.

[[identifier-version-expressions]]
==== Identifier and version expressions

In the core language, an _identifier expression_, with syntax given by `id_expression`, is assigned the type of the unique identifier of the queried entity and evaluates to the unique identifier of a given record. An identifier expression is a synonym for a path expression with one element matching the identifier attribute of the queried entity type. An identifier expression may occur in the `select` clause, in the `order` clause, or as a scalar expression in the `where` clause.

In the extended language, the grammar rule `#entity_id_or_version_function#` gives the syntax of the special functions `id` and `version`, which accept a path expression whose last element is assigned an entity type, and evaluate to, respectively, the identifier or version element of the record to which the path expression evaluates when executed.

NOTE: Record identifiers were defined above in <<structures-and-records>>.
This specification leaves the notion of a _version_ undefined.
Implementations of Jakarta Query are free to interpret this notion in terms of concepts defined externally to this specification.
For example, Jakarta Persistence specifies the notion of a version field or property of an entity.

[[function-calls]]
==== Function calls

A _function call_ is the name of a function recognized by the Jakarta Query implementation, followed by a parenthesized list of argument expressions, with syntax given by:

- `function_expression` in the core language, or
- `#functions_returning_strings#`, `#functions_returning_datetime#`, and `#functions_returning_numerics#` in the full grammar of the extended language.

This specification defines the standard functions listed in the table below.

NOTE: Functions highlighted in yellow belong to the extended language and are not required for an implementation of the core language.

[cols="15,15,15,15,~"]
|===
| Function name | Parameters | Parameter types | Type | Semantics

| `abs` | 1 | Any numeric type | Same as argument | Evaluates to the absolute value of the numeric value to which its argument evaluates.
| `#sign#` | 1 | Numeric | Integer | Evaluates to the sign (-1, 0, or 1) of the numeric value of its argument.
| `#mod#` | 2 | Both integer | Integer | Evaluates to the remainder when its first integer argument is divided by its second integer argument. The behavior is undefined when either or both of the arguments are negative and depends on the data store that is used.
| `#sqrt#` | 1 | Numeric | Double precision | Evaluates to the positive square root of its numeric argument.
| `#exp#` | 1 | Numeric | Double precision | Evaluates to the natural exponential of its numeric argument.
| `#ln#` | 1 | Numeric | Double precision | Evaluates to the natural logarithm of its numeric argument.
| `#power#` | 2 | Both numeric | Double precision | Evaluates to the value produced by raising its first numeric argument to the power specified by its second numeric argument.
| `#ceiling#` | 1 | Any numeric type | Same as argument | Evaluates to the smallest integral value at least as large as its argument.
| `#floor#` | 1 | Any numeric type | Same as argument | Evaluates to the largest integral value at least as small as its argument.
| `#round#` | 2 | Any numeric type, integer | Same as first argument | Evaluates to the value produced by rounding its first numeric argument with the precision given by its second integer argument.
| `length` | 1 | String | Integer | Evaluates to the length of string to which its argument evaluates.
| `lower` | 1 | String | String | Evaluates to the lowercase form of the string to which its argument evaluates.
| `upper` | 1 | String | String | Evaluates to the uppercase form of the string to which its argument evaluates.
| `left` | 2 | String, integer | String | Evaluates to a prefix of the string to which its first argument evaluates. The length of the prefix is given by the integer value to which its second argument evaluates.
| `right` | 2 | String, integer | String | Evaluates to a suffix of the string to which its first argument evaluates. The length of the suffix is given by the integer value to which its second argument evaluates.
| `#concat#` | At least one | All strings | String | Evaluates to the concatenation of its arguments.
| `#substring#` | 2 or 3 | String, integer, integer | String | Evaluates to a specified substring of the first argument. The second and third arguments specify the starting position and length of the substring. The third argument is optional. If it is not specified, the substring from the starting position to the end of the string is returned. The first character of the string is at position `1`.
| `#trim#` | 1^*^ | String | String | Trims a specified character from its last argument. If the character to be trimmed is not specified, the space character is trimmed. The optional `#trim_character#` specifies the character to be trimmed. The optional `#trim_specification#` controls whether the character is trimmed from the start and/or end of the string. By default, the character is trimmed from both start and end.
| `#replace#` | 3 | All strings | String | Evaluates to a new string formed by replacing every occurrence of the second argument string within the first argument string with the third argument string.
| `#locate#` | 2 or 3 | String, string, integer | Integer | Evaluates to the position at which one string occurs within a second string, optionally ignoring any occurrences that begin before a specified character position in the second string. It returns the first character position within the second string (after the specified character position, if any) at which the first string occurs, as an integer, where the first character of the second string is denoted by 1. That is, the first argument is the string to be searched for; the second argument is the string to be searched in; the optional third argument is an integer representing the character position at which the search starts (by default, 1, the first character of the second string). If the first string does not occur within the second string, 0 is returned.
| `#size#` | 1 | Collection | Integer | Evaluates to the number of elements in the collection to which its argument evaluates.
| `#coalesce#` | At least two | Any atomic type `T` | `T` | Evaluates to the value of the first argument expression which evaluates to a non-null value.
| `#nullif#` | 2 | Any atomic type `T` | `T` | Evaluates to the null value if both argument expressions evaluate to the same value, or, otherwise, to the value of the first argument expression.
| `#extract#` | 2 | Any date or time type | See text | See text
|===

When any argument expression of any function call evaluates to a null value, the whole function call evaluates to null.

NOTE: Some of these functions cannot be emulated on every datastore. When a function cannot be reasonably emulated via the native query capabilities of the database, an implementation of Jakarta Query is not required to provide the function.

NOTE: On the other hand, an implementation of Jakarta Query might provide additional built-in functions, and might even allow invocation of user-defined functions.

An implementation Java must assign:

- the type `java.lang.String` to every function of type "String",
- the type `java.lang.Integer` to every function of type "Integer", and
- the type `java.lang.Double` to every function of type "Double precision".

The primitive types `double`, `float`, `long`, `int`, `short`, `byte`, wrappers for these primitive types, `BigInteger`, and `BigDecimal` are all considered "Numeric" types.

In the extended language, the `#extract()#` function accepts an expression assigned a date, time, or datetime type, along with an identifier -- a `#datetime_field#` or `#datetime_part#` -- indicating a specific part of the date, time, or datetime to extract, and evaluates to the specified part of the value to which its argument expression evaluates.

Like keywords, `#datetime_field#` and `#datetime_part#` identifiers are case-insensitive.

[NOTE]
====
As mentioned above in <<atomic-values>>, an implementation of Jakarta Persistence for Java usually supports at least the date/time types `java.time.LocalDate`, `java.time.LocalTime`, and `java.time.LocalDateTime`.
Such implementations are encouraged to also support:

- the `#datetime_field#` identifiers `#YEAR#`, `#QUARTER#`, `#MONTH#`, `#WEEK#`, `#DAY#`, `#HOUR#`, `#MINUTE#`,
`#SECOND#`, and
- the `#datetime_part#` identifiers `#DATE#` and `#TIME#`.

If the first argument of `#extract()#` is a `#datetime_field#` identifier, the function call is assigned the type `Integer`.
If the first argument of `#extract()#` is `#DATE#`, the function call is assigned the type `LocalDate`. If the first argument of `#extract()#` is `#TIME#`, the function call is assigned the type `LocalTime`.

The `#datetime_field#` or `#datetime_part#` must be compatible with the type of the second argument expression.
For example, `extract(day from local date)` is well-typed; `extract(year from local time)` is not.
====

[NOTE]
====
Jakarta Persistence requires support for the `#function()#` function, with syntax given by `#function_invocation#`, allowing invocation of a native or user-defined database function from a query written in JPQL.
On the other hand, an implementation of Jakarta Query might simply allow direct invocation of such functions -- without the requirement to use the `#function()#` syntax -- as an extension to the functionality required by this specification.
This specification does not, therefore, require support for `#function()#`, not even in an implementation of the extended language.

**TODO** Should we simply deprecate it? Remove it?
====

**TODO** `INDEX()`, `VALUE()`, `KEY()`

[[types-and-typecasts]]
==== Types and typecasts

The extended language provides three special functions for working with subtype polymorphism.

[[treat]]
===== Treated path expressions

A _treated path expression_ is an invocation of the special `#treat()#` function, with syntax given by `#treated_entity_path_expression#` and `#treated_joinable_path_expression#`.
The `#treat()#` function accepts:

1. a <<path-expressions,path expression>> whose last element is assigned an entity type, and
2. the name of an entity type -- called the _treated type_ -- which must be a subtype of the entity type assigned to the path expression.

A treated path expression is assigned the treated type.

When a treated path expression is executed, the record produced by evaluating the path expression is compared to the treated type.

- If the record is an <<entities-and-embeddables,instance of>> the treated type, the treated path expression evaluates to the record.
- Otherwise, if the record is not an instance of the treated type, the treated path expression evaluates to the null value.

===== Coercion expressions

A _coercion expression_ is an invocation of the special `#cast()#` function, with syntax given by the last alternatives of `#functions_returning_numerics#` and `#functions_returning_strings#`.
The `#cast()#` function accepts:

1. an expression assigned an atomic type, and
2. the name of an atomic type.

A coerced expression is assigned the named atomic type.

When a coercion expression is executed, the atomic value produced by evaluating the path expression is coerced to the named atomic type.

[IMPORTANT]
====
This specification places no specific requirements on the types which are allowed as arguments of the `#cast()#` function, nor on the behavior of coercion between types.
As suggested by the grammar for `#functions_returning_numerics#` and `#functions_returning_strings#`, implementations of the extended language are strongly encouraged to support at least:

- coercion from string to any numeric type, and
- coercion from any atomic type to string.

However, this part of the grammar should be read as indicative of what should be supported in implementations for Java, and, more specifically, what is required for an implementation of Jakarta Persistence.

The capabilities of the `#cast()#` function vary between client programming languages and between databases.
====

[[entity-type-expressions]]
===== Entity type expressions

An _entity type expression_ is an invocation of the special `#type()#` function, with syntax given by `#type_discriminator#`.
The `#type()#` function accepts an expression assigned an entity type, and, when executed, evaluates to a value which represents the type of the record to which the argument expression evaluates.

An implementation for Java assigns the type `java.lang.Class<? extends E>` where `E` is the Java class mapping the entity type assigned to the argument expression, and an entity type expression evaluates to an instance of `Class` representing the Java class which maps the entity type of the record to which the argument expression evaluates.

[[aggregate-functions]]
==== Aggregate functions calls

An _aggregate function call_ may only occur in the `select` or `having` clause of a query involving <<aggregation,aggregation>>.
Such a clause operates on a list of nested result lists, as specified above in <<projection-and-aggregation>> and <<restriction-and-aggregation>>.
An aggregate function call is evaluated in the context of such a nested list.

This specification defines the standard aggregate functions listed in the table below.

NOTE: Functions highlighted in yellow belong to the extended language and are not required for an implementation of the core language.

[cols="15,15,15,15,~"]
|===
| Function name | Parameters | Parameter types | Type | Semantics

| `count` | 1 | Any type | Long integer | The number of nested list elements for which the argument expression evaluates to a non-null value
| `#min#` | 1 | Any ordered type `O` | `O` | The smallest non-null value of the argument expression over all nested list elements
| `#max#` | 1 | Any ordered type `O` | `O` | The largest non-null value of the argument expression over all nested list elements
| `#sum#` | 1 | Any numeric type `N` | `N` | The sum of non-null values of the argument expression over all nested list elements
| `#avg#` | 1 | Any numeric type `N` | `N` | The average (arithmetic mean) of non-null values of the argument expression over all nested list elements
|===

In the core language, the only allowed aggregate function call is the expression `count(this)`, as specified below in <<select-clause>>.

In the extended language, the syntax for aggregate functions is given by `#aggregate_expression#`.
An aggregate function invocation may specify the keyword `#distinct#`, in which case <<distinct,duplicate elimination>> is applied to the list of values produced by evaluating the argument expression over all elements of the nested list before counting or summing the values.footnote:[Use of `min(distinct ...)` or `max(distinct ...)` is allowed but redundant.]

[[case-expressions]]
==== Case expressions

In the extended language, a _case expression_ has syntax given by `#general_case_expression#` or `#simple_case_expression#`.

A `#general_case_expression#` has:

1. a list of one or more ``#when_clause#``s, each of which has a `conditional_expression` paired with a result `scalar_expression`, and
2. a default `scalar_expression`.

When a general case expression is executed, each `conditional_expression` is evaluated, in order, until one is satisfied.

- If some `conditional_expression` is satisfied, then its result `scalar_expression` is evaluated.
- Otherwise, if no `conditional_expression` is satisfied, the default `scalar_expression` is evaluated.

The whole case expression evaluates to the value produced by the result or default `scalar_expression` which was evaluated.

A `#simple_case_expression#` has:

1. a `#case_operand#`, which must be an atomic valued path expression or an <<entity-type-expressions,entity type expression>>,
2. a list of one or more ``#simple_when_clause#``s, each of which has a tested `scalar_expression` paired with a result `scalar_expression`, and
3. a default `scalar_expression`.

When a simple case expression is executed, the `#case_operand#` is evaluated, and then each tested `scalar_expression` is evaluated, in order, until one produces a value identical to the value of the `#case_operand#`.

- If some tested `scalar_expression` evaluates to the value of the `#case_operand#`, then its result `scalar_expression` is evaluated.
- Otherwise, if no `conditional_expression` is satisfied, the default `scalar_expression` is evaluated.

The whole case expression evaluates to the value produced by the result or default `scalar_expression` which was evaluated.

**TODO** make the `else` clause optional, as in SQL.

[[operator-expressions]]
==== Operator expressions

The syntax of an _operator expression_ is given by the `scalar_expression` rule. Within an operator expression, parentheses indicate grouping.

- The operands of `+`, `-`, `*`, and `/` must be expressions assigned an atomic numeric type. The operators have their usual interpretation in terms of integer or floating point arithmetic, subject to the rules of <<numeric-promotion,numeric promotion>>.
- The operands of `||` must be expressions assigned an atomic type representing character strings. An `||` operator expression evaluates to the concatenation of the character strings obtained by evaluating its operands.

All binary infix operators are left-associative. The relative precedence, from highest to lowest precedence, is given by:

1. `*` and `/`,
2. `+` and `-`,
3. `||`.

The unary prefix operators `+` and `-` have higher precedence than the binary infix operators. Thus, `2 * -3 + 5` means `(2 * (-3)) + 5` and evaluates to `-1`.

NOTE: The precise behavior of numeric operators is outside the scope of this specification and varies according to the database and client programming language.

In an implementation for Java:

- The concatenation operator `||` is assigned the type `java.lang.String`. Its operand expressions must also be of type `java.lang.String`. When executed, a concatenation operator expression evaluates to a new string concatenating the strings to which its arguments evaluate.

- The numeric operators `+`, `-`, `*`, and `/` have the same meaning for primitive numeric types as they have in Java, and operator expressions involving these operators are assigned the types they would be assigned in Java. As an exception, when the operands of `/` are both integers, an implementation of Jakarta Query is not required to interpret the operator expression as integer division if that is not the native semantics of the database. However, portability is maximized when Jakarta Query providers _do_ interpret such an expression as integer division.

- The four numeric operators may also be applied to an operand of wrapper type, for example, to `java.lang.Integer` or `java.lang.Double`. In this case, the operator expression is assigned a wrapper type and evaluates to a null value when either of its operands evaluates to a null value. When both operands are non-null, the semantics are identical to the semantics of an operator expression involving the corresponding primitive types.

- The four numeric operators may also be applied to operands of type `java.math.BigInteger` or `java.math.BigDecimal`.

- A numeric operator expression is evaluated according to the native semantics of the database. In translating an operator expression to the native query language of the database, a Jakarta Query provider is encouraged, but not required, to apply reasonable transformations so that evaluation of the expression more closely mimics the semantics of the Java language.footnote:[As <<mapping-to-java,earlier>> noted, this specification never mandates an inefficient implementation of operations which are implemented by the database itself.]


[WARNING]
====
When a Jakarta Query implementation targets a non-relational database, support for arithmetic operators or support for the use of parentheses to control operator precedence might vary from what is described above.
This specification does not require support for arithmetic operators or grouping parentheses if the underlying datastore does not provide these features among its native querying capabilities.
====

[[subquery-expressions]]
==== Subquery expressions

In the extended language, a `#subquery#` may occur as a `scalar_expression` in many places where an expression of atomic type is legal.
Such a subquery must produce a result list with exactly one element when executed.
When the `scalar_expression` is evaluated, the subquery is executed, and the whole expression evaluates to the single element of the result list of the subquery.

[[numeric-promotion]]
==== Numeric types and numeric type promotion

The type assigned to an operator expression depends on the types of its operand expression, which need not be identical.
Numeric type promotion is defined by the following rules:

* If there is an operand of type `Double` or `double`, the expression is of type `Double`.
* Otherwise, if there is an operand of type `Float` or `float`, the expression is of type `Float`.
* Otherwise, if there is an operand of type `BigDecimal`, the expression is of type `BigDecimal`.
* Otherwise, if there is an operand of type `BigInteger`, the expression is of type `BigInteger`, unless the operator is `/` (division), in which case the expression type is not defined here.
* Otherwise, if there is an operand of type `Long` or `long`, the expression is of type `Long`, unless the operator is `/` (division), in which case the expression type is not defined here.
* Otherwise, if there is an operand of integral type, the expression is of type `Integer`, unless the operator is `/` (division), in which case the expression type is not defined here.

[[predicates]]
=== Conditional expressions

A _conditional expression_ is a sequence of tokens which specifies a condition which, for a given record, might be _satisfied_ or _unsatisfied_. Unlike the scalar <<Expressions>> defined in the previous section, a conditional expression is not considered to have a well-defined type.

NOTE: The Jakarta Persistence specification defines the result of a conditional expression in terms of ternary logic. This specification does not specify that a conditional expression evaluates to a well-defined value, only the effect of the conditional expression when it is used as a restriction. The "value" of a conditional expression is not considered observable by the application program.

Conditional expressions may be categorized as:

- <<null-comparisons,`null` comparisons>>,
- <<in-expressions,`in` expressions>>,
- <<between,`between` expressions>>,
- <<like,`like` expressions>>,
- <<equality-and-inequality,equality and inequality>> operator expressions,
- <<quantifiers,quantified conditional expressions>>, and
- <<logical-operators,logical operator expressions>>.

The syntax for conditional expressions is given by the `conditional_expression` rule. Within a conditional expression, parentheses indicate grouping.

[[null-comparisons]]
==== Null comparisons

A `null` comparison, with syntax given by `null_comparison_expression`, is satisfied when:

- the `not` keyword is missing, and its operand evaluates to a null value, or
- the `not` keyword occurs, and its operand evaluates to any non-null value.

[[in-expressions]]
==== In expressions

In the core language, an `in` expression, with syntax given by `in_expression`, must have:

- a <<path-expressions,path expression>> as the leftmost operand, and
- a parenthesized list of one or more ``in_item``s, each of which must be a <<literal-expressions,literal>>, <<enum-literals,enum literal>>, or <<parameters,parameter>>.

All operands must have the same type.

**TODO** We should relax the restrictions on the left operand.

In the extended language, the leftmost operand must be a path expression assigned an atomic type or an <<entity-type-expressions,entity type expression>>, and there must be exactly one of the following elements:

- a parenthesized list of one or more ``in_item``s, each of which must be a <<literal-expressions,literal>>, an <<enum-literals,enum literal>>, a <<entity-type-literals,literal entity type>>, `true`, `false`, or a <<parameters,parameter>>, and each having the same assigned type as the leftmost operand,
- a parenthesized subquery with a `#simple_select_expression#` expression with the same assigned type as the leftmost operand, or
- an unparenthesized parameter.footnote:[Jakarta Persistence treats this parameter as a _collection-valued input parameter_.]

If the condition has a list of expressions, it is satisfied when its leftmost operand evaluates to a non-null value, and:

- the `not` keyword is missing, and any one of its parenthesized operands evaluates to the same value as its leftmost operand, or
- the `not` keyword occurs, and none of its parenthesized operands evaluate to the same value as its leftmost operand.

If the condition has a subquery, it is satisfied when its leftmost operand evaluates to a non-null value, and:

- the `not` keyword is missing, and the value produced by evaluating the left operand occurs in the result list of the subquery, or
- the `not` keyword occurs, and the value produced by evaluating the left operand does not occur in the result list of the subquery.

If the condition has an unparenthesized parameter, it is satisfied when its leftmost operand evaluates to a non-null value, and:

- the `not` keyword is missing, and the value produced by evaluating the left operand is a member of the value assigned to the parameter, or
- the `not` keyword occurs, and the value produced by evaluating the left operand is not a member of the value assigned to the parameter.

[[between]]
==== Between expressions

A `between` expression, with syntax given by `between_expression` is satisfied when its operands all evaluate to non-null values, and, if the `not` keyword is missing, its left operand evaluates to a value which is:

- larger than or equal to the value taken by its middle operand, and
- smaller than or equal to the value taken by its right operand.

Or, if the `not` keyword occurs, the left operand must evaluate to a value which is:

- strictly smaller than the value taken by its middle operand, or
- strictly larger than the value taken by its right operand.

All three operands must have the same type.

[[like]]
==== Like expressions

A `like` expression has syntax given by `like_expression`.

- Its left operand must be an expression assigned some atomic type representing character strings.
- Its right operand must be a pattern given as a literal string, with syntax `literal_pattern`, or, in the extended language, a <<parameters,parameter>>.


If an implementation of Jakarta Query targets clients written in Java, it must allow expressions assigned the type `java.lang.String` as the left operand of a `like` expression.

The expression is satisfied when its left operand evaluates to a non-null value and:

- the `not` keyword is missing, and this value matches the pattern, or
- the `not` keyword occurs, and the value does not match the pattern.

Matching is lexicographic.
Within the pattern, the characters `_` and `%` are interpreted as wildcards:

- `_` matches any single character, and
- `%` matches any contiguous sequence of (zero or more) characters.

Any other character occurring in the pattern is interpreted literally and matches only itself.

In the extended language, a `like_expression` may specify an `#escape_character#`.
An escape character may be used to suppress the interpretation as a wildcard of a particular `_` or `%` character in the pattern.

That is, if the escape character is `c`, then the character bigram `c_` is interpreted literally as the character `_`, the bigram `c%` as the character `%`, and the bigram `cc` as the character `c`.

**TODO** add the escape character to the core language because it is needed by Jakarta Data's Like constraint

[[equality-and-inequality]]
==== Equality and inequality operators

The equality and inequality operators are `=`, `&lt;&gt;`, `&lt;`, `&gt;`, `&lt;=`, `&gt;=`.

The operands of an equality or inequality operator must have the same type,
 and it must be an atomic type considered _comparable_ by the implementation of Jakarta Query.
Any type with a <<natural-order,natural order>> must be treated as a comparable type, and the equality and inequality operators must be interpreted in a way which is consistent with the natural order.

For non-null values, the following table defines an interpretation consistent with the natural order:

[cols="15,~"]
|===
| Operator | Interpretation in terms of natural order

| `x < y` | Satisfied if `x` occurs before `y` in the natural order
| `x > y` | Satisfied if `x` occurs after `y` in the natural order
| `x <= y` | Satisfied if `x>y` is not satisfied
| `x >= y` | Satisfied if `x<y` is not satisfied
| `x = y` | Satisfied if neither `x>y` nor `x<y` is satisfied
| `x <> y` | Satisfied if either `x>y` or `x<y` is satisfied
|===

When exactly one of the operands of an equality or inequality operator evaluates to a null value, the conditional expression is not satisfied.

NOTE: When both operands of an equality or inequality operator evaluate to null, the behavior is not defined by this specification.
As mentioned above in <<atomic-values>>, the semantics of comparisons involving two null values depends on the underlying database -- typically, on whether the database uses binary or ternary logic.

In an implementation of Jakarta Query which targets clients written in Java, every primitive or primitive wrapper type is considered comparable, along with `java.lang.String`, `java.math.BigInteger`, `java.math.BigDecimal`, and types representing dates and datetimes.

- For primitive types, these operators have the same meaning they have in Java, except for `<>` which has the same meaning that `!=` has in Java. Such an operator expression is satisfied when the equivalent operator expression would evaluate to `true` in Java.
- For wrapper types, these operators are satisfied if both operands evaluate to non-null values, and the equivalent operator expression involving primitives would be satisfied.
- For other types, these operators are usually evaluated according to the native semantics of the database.

NOTE: Portability is maximized when Jakarta Query providers interpret equality and inequality operators in a manner consistent with the implementation of `Object.equals()` or `Comparable.compareTo()` for the assigned Java type.
footnote:[A notable special case is `java.math.BigDecimal`, whose implementation of `equals()` is inconsistent with its implementation of `compareTo()`. For `BigDecimal`, the `=` operator in Jakarta Data should be implemented for consistency with `compareTo()`.]

In the extended language, the right operand of an equality or inequality operator may be a subquery, as discussed in the <<quantifiers,next section>>.

[WARNING]
====
When a Jakarta Query implementation targets a non-relational database, support for equality and inequality operators might vary from what is described above.
This specification does not require support for use of an equality or inequality operator if the underlying datastore does not provide this operator in its native querying capabilities.
For example, some non-relational databases might only allow lookup by key, and in such databases only the entity <<structures-and-records,identifier>> may be used in an equality comparison expression.footnote:[In Jakarta NoSQL, the key attribute is identified by the annotation `jakarta.nosql.Id`.]

**TODO** Why does Jakarta Data not have a similar caveat applying to `between`, `like`, `in`, and  `is null`? Do we need to generalize the language above to other sorts of conditional expressions?
====

[[quantifiers]]
==== Quantified conditional expressions

In the extended language, there are two kinds of conditional expression involving quantification:

- _existence expressions_, with syntax given by `#exists_expression#`, and
- _quantified comparison expressions_, in which the right operand of an <<equality-and-inequality,equality or inequality operator>> is an `#all_or_any_expression#`.

In either case, a `#subquery#` occurs as the argument of one of the following special quantifier functions: `#exists#`, `#all#`, `#any#`, or `#some#`.
When a quantifier is evaluated, the subquery is executed, producing a result list containing values which are instances of some atomic or entity type.
For a quantified comparison expression, the type of these values must be the same as the type of the left operand of the equality or inequality operator.

An existence expression is satisfied if and only if:

- the `not` keyword is missing, and the result list of the subquery is nonempty, or
- the `not` keyword is present, and the result list of the subquery is empty.

A quantified comparison expression is satisfied if and only if:

- the quantifier is `#any#` or `#some#` and the result list of the subquery contains at least one value which would make the equality or inequality expression evaluate to true if it occurred as the right operand in place of the subquery, or
- the quantifier is `#all#` and every value belonging to the result list of the subquery would make the equality or inequality expression evaluate to true if it occurred as the right operand in place of the subquery.

[[natural-order]]
=== Natural order

Every <<atomic-values,atomic value type>> can, in principle, be equipped with a total order. An order for a type determines the result of <<equality-and-inequality,inequality comparisons>> and the effect of the <<order-clause>>.

For any numeric type, or for any date or datetime type, there is a _natural order_ for non-null values completely determined by the semantics of the type. Jakarta Query implementations must sort these types according to their natural order:

- smaller numeric values come before larger numeric values, and
- earlier dates or datetimes come before later dates or datetimes.

NOTE: For an implementation of Jakarta Query which targets clients written in Java, this natural order agrees with the order defined by the corresponding Java type from `java.lang`, `java.math`, or `java.time`.

Furthermore, Jakarta Query implementations must sort boolean values so that `false < true` is satisfied.

For other types, there is at least some freedom in the choice of order. Usually, the order is determined by the native semantics of the database.

[CAUTION]
====
For clients written in Java, note that:

- Textual data is represented in Java as the type `java.lang.String`. Strings are in general ordered lexicographically, but the ordering also depends on the character set and collation used by the database server. Applications must not assume that the order agrees with the `compareTo()` method of `java.lang.String`. In evaluating an inequality involving string operands, an implementation of Jakarta Query is not required to emulate Java collation.

- Binary data is represented in Java as the type `byte[]`. Binary data is in general ordered lexicographically with respect to the constituent bytes. However, since this ordering is rarely meaningful, this specification does not require implementations of Jakarta Query to respect it.

- This specification does not define an order for the sorting of Java `enum` values, which is provider-dependent. An implementation of Jakarta Query might allow control over the order of `enum` values. For example, Jakarta Persistence allows this via the `@Enumerated` annotation.

- This specification does not define an order for UUID values, which is completely implementation-dependent. Applications must not assume that the order agrees with the `compareTo()` method of `java.util.UUID`.
====

The natural order does not determine the precedence of null values, and so this specification leaves their precedence undefined except when `nulls first` or `nulls last` is explicitly specified for an item of the order by clause, as defined by <<order-clause>>.

[[logical-operators]]
=== Logical operators

The logical operators are `and`, `or`, and `not`.

- An `and` operator expression is satisfied if and only if both its operands are satisfied.
- An `or` operator expression is satisfied if at least one of its operands is satisfied.
- A `not` operator expression is never satisfied if its operand _is_ satisfied.

This specification leaves undefined the interpretation of the `not` operator when its operand _is not_ satisfied.

CAUTION: A compliant implementation of Jakarta Query might feature SQL/JPQL-style ternary logic, where `not n > 0` is an unsatisfied logical expression when `n` evaluates to null, or it might feature binary logic where the same expression is considered satisfied. Application programmers should take great care when using the `not` operator with scalar expressions involving `null` values.

Syntactically, logical operators are parsed with lower precedence than <<Equality and inequality operators,equality and inequality operators>> and other <<Conditional expressions,conditional expressions listed above>>. The `not` operator has higher precedence than `and` and `or`. The `and` operator has higher precedence than `or`.

[WARNING]
====
When a Jakarta Query implementation targets a non-relational database, support for logical operators might vary from what is described above.
This specification does not require support for logical operators if the underlying datastore does not provide a functionally equivalent way to restrict query results among its native querying capabilities.
====
