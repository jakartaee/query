[[algebra]]
== Basic operations

A query is a sequence of operations acting on lists of structures:

- specification of an initial **root entity**,
- a sequence of **joins** to joined entities, collections, or embeddable types,
- **restriction**,
- **aggregation**,
- more **restriction**,
- **projection**,
- **duplicate elimination**, and
- **ordering**.

For queries without <<subqueries,nesting>>, these operations may be viewed as a pipeline.footnote:[Subqueries complicate the picture; a query involving subqueries is conceptually a tree.]
Each operation may then be thought of as a stage of the pipeline.
Some stages may be missing in a given query.
The only required stage is the first stage: specification of the root entity.

Each operation in the pipeline produces a _result list_.
A result list is a list in the sense of the previous chapter.
The elements of a result list are always structures.
Thus, every result list has a well-defined type, which we sometimes call its _shape_, according to the rules specified <<collections,above>>.
A result list may contain two or more structures which are identical in the sense of <<structures-and-records>>.

Each operation from the list above--except for the first operation, specification of the root entity--acts on the output of the previous stage.
When evaluated, the operation produces its result list by transforming the result list produced by the previous stage.

A join or root entity has access not only to the result list of its previous stage, but also to the content of a database.
A query is executed against a specific database and any operation which ranges over an entity type ranges only over those records which belong to the database.
From now on, the database itself will usually be implicit, and we will not explicitly specify that the records under consideration must belong to the database.

Finally, the binary operations **union**, **intersection**, and **complementation** may be used to join the outputs of multiple pipelines.

[[root-entity]]
=== The root entity

Every query begins with a _root entity_.
A root entity is specified using the syntax:

[source,sql]
----
from X
----

where `X` is the name of the entity.

// This is the simplest possible query, and it simply returns every record of a given entity type.footnote:[That is, it returns every record of the given entity type _belonging to a given database_.]

We may assign a label to the root entity of the query using the syntax:

[source,sql]
----
from X as x
----

which may be abbreviated as:

[source,sql]
----
from X x
----

The label `x` must be a legal Java identifier.
This label is often called an _alias_ or _identification variable_.

When no label is explicitly specified, the root entity is assigned the implicit label `this`.

A root entity specification evaluates to a result list containing a structure for each record of the root entity type or of any entity type which inherits the root entity type.
Each structure contains a single labeled element: the record, labeled by the alias `x`.

That is, for each record _r_ in the database, the result list has a structure _s_ containing _r_ labeled by `x` if and only if the type of _r_ <<inheritance,inherits>> the root entity type.
The structure _s_ contains no other elements.

For example, the query `from Book` might return a list containing structures like:

[source,json]
----
{
  this: {
    isbn: "9781857232738",
    title: "Feersum Endjinn",
    pages: 279,
    year: 1994,
    authors: [
      {
        name: "Iain M. Banks",
        born: 'February 16, 1954',
        died: 'June 9, 2013'
      }
    ]
  }
}
----

And the query `from Book as book` returns a list containing structures like:

[source,json]
----
{
  book: {
    isbn: "9781857232738",
    title: "Feersum Endjinn",
    pages: 279,
    year: 1994,
    authors: [
      {
        name: "Iain M. Banks",
        born: 'February 16, 1954',
        died: 'June 9, 2013'
      }
    ]
  }
}
----

[[joins]]
=== Joins

Every join has a _target_, which must be:

- an entity,
- a collection, or
- an embeddable type.

A join introduces a new labeled element to a result list.
Evaluating a sequence of joins produces a result list in which each structure contains a labeled element corresponding to each join.
The label of this element is often called the _alias_ or _identification variable_ of the join.

[[joins-entities]]
==== Joins to named entities

A join may specify the name of an entity:

[source,sql]
----
[from], Y as y
----

where `Y` is the name of the entity, `y` is the label (alias) assigned to it, and `[from]` is a root entity or a join.
As before, the keyword `as` is optional.

This kind of join produces a cartesian product.
For each structure _r_ of the result list of the operation on which the join acts, and for each record _y_ of any entity type which inherits `Y`, the result list contains a structure _r'_ containing all labeled elements of _r_ together with the record _y_ labeled by the alias `y`.

For example, this query is a cartesian product:

[source,sql]
----
from Book as book, Loan as loan
----

This query evaluates to a result list containing a structure for each pairing of a record of entity `Book` with a record of entity `Loan`.
The structure contains two labeled elements, one for each entity, each labeled by its corresponding alias, `book`, and `loan`, respectively.
The list might contain structures this:

[source,json]
----
{
  book: {
    isbn: "9781857232738",
    title: "Feersum Endjinn",
    pages: 279,
    year: 1994,
    authors: [
      {
        name: "Iain M. Banks",
        born: 'February 16, 1954',
        died: 'June 9, 2013'
      }
    ]
  },
  loan: {
    bookIsbn: "9781932394153",
    borrowerCard: "XYZ-123"
  }
}
----

Note that there is no meaningful relationship between the `book` and the `loan`.

A join to a named entity may be immediately followed by a <<restriction,restriction>>.
In this case, the syntax is slightly different:

[source,sql]
----
[from] join Y as y on [predicate]
----

where `[predicate]` is a predicate, as defined later in <<predicates>>.

For example:
[source,sql]
from Book as book
join Loan as loan
    on book.isbn = loan.bookIsbn

This kind of join is interpreted as a sequence of two operations, a join of the previous kind, with no `on`, followed by a <<restriction,restriction>> with the given predicate.

The result of the query might contain structures like:

[source,json]
----
{
  book: {
    isbn: "9781857232738",
    title: "Feersum Endjinn",
    pages: 279,
    year: 1994,
    authors: [
      {
        name: "Iain M. Banks",
        born: 'February 16, 1954',
        died: 'June 9, 2013'
      }
    ]
  },
  loan: {
    bookIsbn: "9781857232738",
    borrowerCard: "ABC-098"
  }
}
----

This time, `isbn` and `bookIsbn` agree.

[[joins-nested]]
==== Joins to nested entities or collections

Instead of a named entity, a join may identify a structure or collection nested within the result list of the operation on which it acts:

[source,sql]
----
[from] inner join [path] as y
----

where `[path]` is a path expression, as defined later in <<path-expressions>>, and `y` is the label.

As usual, the keyword `as` is optional.
The keyword `inner` is also completely optional, and so a join may be written:

[source,sql]
----
[from] join [path] as y
----

For example:

[source,sql]
----
from Book as book
join book.authors as author
----

The path expression identifies a structure nested within the result list of the operation on which the join acts.

For each structure _r_ of the result list of the operation on which the join acts:

- If the path expression resolves to a structure _s_, the result list contains a structure _r'_ containing all labeled elements of _r_ together with the structure _s_ labeled by the alias `y`.
- If the path expression resolves to a collection _c_, the result list contains, for each element _e_ of _c_, a structure _r'_ containing all labeled elements of _r_ together with the structure _e_ labeled by the alias `y`.

The previous example evaluates to a list containing a structure for each `Author` of each `Book`.
The structure contains two labeled elements, one for each entity, each labeled by its corresponding alias, `book`, and `author`, respectively.
The list might contain structures like this:

[source,json]
----
{
  book: {
    isbn: "9781857232738",
    title: "Feersum Endjinn",
    pages: 279,
    year: 1994,
    authors: [
      {
        name: "Iain M. Banks",
        born: 'February 16, 1954',
        died: 'June 9, 2013'
      }
    ]
  },
  author: {
    name: "Iain M. Banks",
    born: 'February 16, 1954',
    died: 'June 9, 2013'
  }
}
----

Notice that this kind of join has the effect of duplicating nested structures or atomic values at the top level of the of structure belonging to the result list.

[NOTE]
This picture should not be taken too literally.
Implementations of Jakarta Query do not, in practice, always return the entire result of a query to the client, but instead replace some branches of the graph with some sort of proxy object.

A join to a structure or collection may be immediately followed by a <<restriction,restriction>>.

[source,sql]
----
[from] inner join [path] as y on [predicate]
----

where `[predicate]` is a predicate, as defined later in <<predicates>>.

This kind of join is interpreted as a sequence of two operations: a join of the previous kind, with no `on`, followed by a <<restriction,restriction>> with the given predicate.


[[left-joins]]
==== Left joins

A left join is similar to a regular join:

[source,sql]
----
[from] left outer join [path] as y
----

where `[path]` is a path expression, as before, and `y` is the label.

As usual, the keyword `as` is optional.
The keyword `outer` is also completely optional, and so a left join may be written:

[source,sql]
----
[from] left join [path] as y
----

For example:

[source,sql]
----
from Book as book
left join book.authors as author
----

The path expression identifies a structure nested within the result list of the operation on which the join acts.

For each structure _r_ of the result list of the operation on which the join acts:

- If the path expression resolves to a structure _s_, the result list contains a structure _r'_ containing all labeled elements of _r_ together with the structure _s_ labeled by the alias `y`.
- If the path expression resolves to a nonempty collection _c_, the result list contains, for each element _e_ of _c_, a structure _r'_ containing all labeled elements of _r_ together with the structure _e_ labeled by the alias `y`.
- Otherwise, if a path expression resolves to no structure, or to an empty collection, the result list contains a structure _r'_ containing only the labeled elements of _r_.

Just like regular joins, a left join may be followed by a restriction:

[source,sql]
----
[from] left outer join [path] as y on [predicate]
----

In this case, however, the restriction is only evaluated for elements of the result list which contain structures labeled by the alias `y`.
Any element of the result list of the join which does not contain a structure labeled by the alias `y` is taken to satisfy the restriction, even when the predicate would not be satisfied by that element.

[[fetch-joins]]
==== Fetch joins

A fetch join is a hint to the Jakarta Query implementation regarding which data in the query result set the application program will access.
A fetch join does not affect the shape (type) of the query result set, and therefore does not introduce a label.
Otherwise, the syntax is similar to a left join:

[source,sql]
----
[from] left outer join fetch [path]
----
[source,sql]
----
[from] left join fetch [path]
----

NOTE: The sister specifications of this specification assign semantics to this syntax.

[[restriction]]
=== Restriction

_Restriction_, also called _selection_, reduces the size of a result list, without modifying its type.

Restriction may occur before or after aggregation, or, as we already saw <<joins,above>>, it may occur immediately after a join.

When restriction precedes aggregation, the syntax is:

[source,sql]
----
[from] where [predicate]
----

where `[predicate]` is a logical <<predicates,predicate>> expression.

When restriction follows aggregation, the syntax is:

[source,sql]
----
[group-by] having [predicate]
----

where `[group-by]` is a legal <<aggregation,aggregation>>.

Restriction eliminates every element of the result list which does not satisfy the given predicate expression, as defined later in <<predicates>>.
That is, the result list of a restriction contains a structure _r_ if and only if:

- _r_ is in the result list of the operation on which the restriction acts, and
- _r_ satisfies the logical predicate.

[[restriction-and-aggregation]]
==== Restriction and aggregation

When restriction is applied to a query involving aggregation, the predicate may only involve:

- value expressions which also occur in the `group by` clause, and
- aggregate function expressions, as specified below in <<aggregate-functions>>.

In this case, the restriction eliminates entire nested lists belonging to the result list of the aggregation operation.

[[aggregation]]
=== Aggregation

_Aggregation_ groups the elements of a result list into sublists.
That is, it transforms a list into a list of lists.

Aggregation follows a root entity or join:

[source,sql]
----
[from] group by [expression], [expression], ...
----

where each `[expression]` is a value expression, as defined later in <<value-expressions>>.

1. For each structure _r_ of the result list of the operation on which the ordering operation acts, a _grouping tuple_ is constructed by evaluating each of the value expressions specified by the aggregation in the context of the structure _r_, and packaging the resulting atomic values in a structure _t_ where each value is labeled by the position of the value expression in the `group by` clause.

2. For each distinct resulting value _t_ of the grouping tuple, a nested list _l~t~_ is constructed containing every structure _r_ which produced that value of the grouping tuple.

3. Finally, the result list of the aggregation contains every such nested list _l~t~_.

Each value expression must evaluate to an atomic value or record.

[NOTE]
If a value expression evaluates to a record, the record may be replaced by its identifier in the grouping tuple.

[[projection]]
=== Projection

_Projection_ changes the type of a result list without modifying its size.

A projection is written in the form:

[source,sql]
----
[result] select [expression] as x, [expression] as y, ...
----

or, more conventionally, but much more confusingly, in the form:

[source,sql]
----
select [expression] as x, [expression] as y, ... [result]
----

where `x`, `y`, ... are all labels and `[result]` is a root entity, join, restriction, or aggregation, and each `[expression]` is a value expression, as defined later in <<value-expressions>>.

As usual, the `as` keyword is optional, and the labels must be legal Java identifiers.

The labels, sometimes called _aliases_, are optional.
If a label is missing from a value expression, the value expression is automatically assigned a label.

[NOTE]
For historical reasons, the label defaults to the integer position of the value expression in the `select` list.
This is unfortunate because an integer is not a legal Java identifier, and therefore not a legal label.
Such defaulted labels may not be referred to in the query language except--again for historical reasons--in the `order by` clause.

Projection produces a new structure _r'_ for each structure _r_ in the result list of the operation on which the projection acts.
The new structure  _r'_ is built by evaluating the value expressions specified by the projection in the context of the corresponding element structure _r_, according to semantics given later in <<value-expressions>>.
For each value expression with label `x` in the given `select` list, _r'_ contains a element labeled `x` obtained by evaluating the value expression in the context of _r_.

For example:

[source,sql]
----
from Book as book
join book.authors as author
select book.isbn as isbn, book.title as title, author.name as author
----

returns a list containing elements like:

[source,json]
----
{
    isbn: "9781857232738",
    title: "Feersum Endjinn",
    author: "Iain M. Banks"
}
----

[[projection-and-aggregation]]
==== Projection and aggregation

When projection is applied to a query involving aggregation, every value expression in the `select` list must be either:

- a value expression which also occurs in the `group by` clause, or
- an aggregate function expression, as specified below in <<aggregate-functions>>.

In this case, the projection has the additional effect of collapsing the list of lists produced by aggregation, producing a single result structure for each nested list in the result list of the operation to which the projection applies.

Alternatively, if every value expression in the `select` list is an aggregate function, and if the query does _not_ have a `group by` clause, then aggregation over all elements of the result list is implied.footnote:[That is, the query functions as if it had an empty `group by` clause with no value expressions, so that every element of the result list was assigned a grouping tuple of length zero, resulting in a result list containing a single nested list.]
Such a query produces a result list with a single element.

A query with no `group by` clause may not mix aggregate function expressions with other value expressions.

[[distinct]]
=== Duplicate elimination

The `distinct` keyword, placed after `select`, specifies that duplicate structures should be eliminated from the result list.
Two structures are considered duplicates if they are identical in the sense defined in <<structures-and-records>>.

Suppose the result list of a projection contains _n ≥ 0_ identical copies of a structure _r_.
Then duplicate elimination produces a result list containing (exactly one instance of) the structure _r_ if and only _n ≥ 1_.
Thus, any two structures belonging to the final result list are distinct (non-identical).

Duplicate elimination does not change the shape (type) of the result list.

[[ordering]]
=== Ordering

Ordering changes the order of the elements in a result list, without changing the size or type of the list.

Ordering is the last operation of a query:

[source,sql]
----
[result] order by [order], [order], ...
----

where `[result]` is a root entity, join, restriction, aggregation, or projection, and each `[order]` is an ordering criterion comprising:

- a value expression, subject to the restrictions given below, and
- optionally, `asc` or `desc`, specifying ascending or descending order, and
- optionally, `nulls first`, or `nulls last`, specifying the precedence of null values.

If neither `asc` nor `desc` is explicitly specified, ascending order is assumed.
If neither `nulls first` nor `nulls last` is explicitly specified, the precedence of null values is not defined by this specification.

1. For each structure _r_ of the result list of the operation on which the aggregation acts, an _ordering tuple_ is constructed by evaluating each of the value expressions specified by the ordering operation in the context of the structure _r_, and packaging the resulting atomic values in a structure _t_ where each value is labeled by the position of the value expression in the `group by` clause.

2. The result list is sorted according to the lexicographic order of the resulting ordering tuples.

[NOTE]
This specification does not specify an order for atomic values or structures.
Such ordering is typically determined by the database itself.
Some general principles for ordering of atomic types are established in <<natural-order>>.

Each value expression in the `order by` list must also occur in the projection list. TODO!

For example:

[source,sql]
----
from Book as book
join book.authors as author
select book.isbn as isbn, book.title as title, author.name as author
order by book.isbn desc
----

[[union-intersection]]
=== Union, intersection, and complement

The results of two queries may be combined via union, intersection, or complementation of their result lists viewed as sets.
The syntax of a _union_, _intersection_, or _complement_ is, respectively:

[source,sql]
----
[query] union [query]
----
[source,sql]
----
[query] intersect [query]
----
[source,sql]
----
[query] except [query]
----

where each `[query]` is a complete query pipeline as described above.

The `union`, `intersect`, and `except` operators are operators on sets.
That is, they:

- produce result lists with distinct elements, and
- are not required to preserve any element ordering which might exist in the result lists being combined.

Suppose a `union`, `intersect`, or `except` operator is applied to the result lists _l~L~_ and _l~R~_, with _l~L~_ occurring to the left.
The final result list contains a structure _r_ if and only if:

1. the operator is `union`, and _r_ occurs in either _l~L~_ or _l~R~_,
2. the operator is `intersect`, and _r_ occurs in both _l~L~_ or _l~R~_, or
3. the operator is `except`, and _r_ occurs in _l~L~_ but not in _l~R~_.

The semantics of union, intersection, or complementation may be modified by the `all` keyword:

[source,sql]
----
[query] union all [query]
----
[source,sql]
----
[query] intersect all [query]
----
[source,sql]
----
[query] except all [query]
----

When `all` occurs, the operation preserves duplicate results from the argument result lists and so the final result list might contain duplicate elements.

Suppose a `union all`, `intersect all`, or `except all` operator is applied to the result lists _l~L~_ and _l~R~_, with _l~L~_ occurring to the left.
Given a structure _r_ which occurs _n~L~_ times in _l~L~_ and _n~R~_ times in _l~R~_:

1. _r_ occurs _n~L~_ + _n~R~_ times in the final result list if the operator is `union all`,
2. _r_ occurs min(_n~L~_, _n~R~_) times in the final result list if the operator is `intersect all`, or
3. _r_ occurs max(0, _n~L~_ - _n~R~_) times in the final result list if the operator is `except all`.

[NOTE]
====
In principle, a union may act on result lists of distinct type, producing a result list containing structures of heterogeneous type.
This specification requires union, intersection, or complementation only for lists of identical type because many data stores are not capable of unions that produce lists of heterogeneous type.
Some implementations allow unions of lists containing entities of distinct type when the entity types are related by <<inheritance,inheritance>>, but that functionality is not required by this specification.
====
