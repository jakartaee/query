== Type system

This specification assumes that data is represented in a structured form, that is, that it is expressed in terms of:

1. **atomic values**,
2. **collections**, and
3. **structures**.

Any atomic value, collection, or structure belongs to at least one well-defined type.

[[atomic-values]]
=== Atomic values

_Atomic values_ are things defined externally to this specification, taken to include--at bare minimum--strings of Unicode characters, `true` and `false`, integers, floating point numbers, and dates, times, and datetimes.
Every atomic value has a named type, referred to in the sister-specifications of this specification as a _basic type_.

[NOTE]
The atomic value types allowed by an implementation of Jakarta Query depend on the programming language and underlying database technology.

Atomic values of distinct type are never considered identical (equal).
Whether two atomic values of the same type are considered identical depends on semantics which are specific to the type.
For example, two Unicode strings are identical if they have the same length and the same Unicode character at each position.
Identity for a given atomic value type must be reflexive, symmetric, and transitive.

[[collections]]
=== Collections

A _collection_ is a finite set, list, or map containing atomic values or structures.
A collection might contain atomic values, or it might contain structures.
The keys of a map must be atomic values.

Collections are homogeneous.
A collection may not contain both atomic values and structures.

- If a collection contains atomic values, then every atomic value has the same type.
- If a collection contains structures, then every structure has the same type.
- As an exception to the previous rule, a collection may contain structures belonging to distinct <<entities-embeddables,entity types>> if there is some entity type which is <<inheritance,inherited>> by the type of every structure contained in the collection.
- Every key of a map has the same atomic value type.

A collection therefore has a type derived from the type of the atomic values or structures it contains--and, for a map, from the type of its keys.
We consider that two collections have the same type if they contain the same type of atomic value or structure.
For a map, we also require that they have the same type of key.

A collection has no identity independent of the values it contains.

- Two sets are identical if they contain exactly the same elements.
- Two lists are identical if they contain exactly the same elements at exactly the same positions.
- Two maps are identical if they contain exactly the same keys, and identical values for each key.

[[structures-and-records]]
=== Structures and records

A _structure_ is a finite set of labelled elements, each of which is an atomic value, a nested structure, or a collection.

Structures are inhomogeneous.
Elements with distinct labels may have distinct types.

Every structure has a type derived from the types of its elements.
We consider that two structures have the same type if:

- they contain the same labels, and
- for each label, the labelled elements have the same type.

A structure has no identity independent of the labelled elements it contains.
Two structures are identical if they contain exactly the same labels, and identical atomic values, collections, or nested structures for each label.

For example--borrowing a convenient notation--the following structure might represent a book:

[source,json]
----
{
  isbn: "1-85723-235-6",
  title: "Feersum Endjinn",
  pages: 279,
  year: 1994,
  authors: [
    {
      name: "Iain M. Banks",
      born: 'February 16, 1954',
      died: 'June 9, 2013'
    }
  ]
}
----

A _record_ is a special kind of structure.
Every record must have an _identifier_ which uniquely distinguishes it from other structures with the same type.
The identifier must be a subset of the labelled elements of the structure.

For example, `{ isbn: "1-85723-235-6" }` might be an identifier of the structure given above.

[[entities-embeddables]]
=== Entities and embeddable types

A structure type might be assigned a static name.footnote:[That is, the name is assigned to the type before the program using Jakarta Query is compiled and executed.]

- An _embeddable type_ is an assignment of a name to a given type of structure.
  For example, we might assign the name `Author` to the type of the structure:

    {
      name: "Iain M. Banks",
      born: 'February 16, 1954',
      died: 'June 9, 2013'
    }

- An _entity_ (or _entity type_) is an assignment of a name to a given type of record.
For example, we might assign the name `Book` to the type of the record given in the example above.

The name must be a legal Java identifier.
That is, it must be a string of letters and digits, along with the characters `\_` and `$`, and must begin with a letter or with `_`.footnote:[Use of `_` or `$` in the name of an entity is discouraged.]

It follows from this definition that we may express:

- an embeddable type as a set of labels, together with their types,
- an entity as a set of labels, together with their types, and whether they belong to the record identifier.

For example:

[source]
----
Author :=
{
    name: String,
    born: LocalDate,
    died: LocalDate
}

Book :=
{
  isbn: @Id String,
  title: String,
  pages: Integer,
  year: Integer,
  authors: Set<Author>
}
----

A record with the same type as an entity type is said to be an _instance_ (or _instantiation_) of the entity.
Similarly, a structure with the same type as an embeddable type is said to be an instance of the embeddable type.
footnote:[In some implementations, it might be possible to assign multiple names to a single structure type, and then a given instance of that type might be considered to belong to just one of the named entity or embeddable types. We do not address this wrinkle here, since implementations of Jakarta Query are not required to allow this.]

An entity is directly addressable in a query.
An atomic value type, a collection type, or a structure type which is not an entity is not directly addressable, and must be addressed indirectly via an entity.

[NOTE]
Some database technologies are capable of storing an arbitrary structure whose type is not known at compile time.
Other technologies require that the structure belong to a defined entity or embeddable type.
Independent of the database technology itself, an implementation of Jakarta Query might require that structure types be named, or might offer a way to encode and store generic structures.
Implementations of Jakarta Query are not required to support storage of such generic structures.

[NOTE]
The name of an entity might be involved in mapping an association between a type defined in a programming language (for example, a Java class) and an area of storage in the database (for example, a table).
Such mappings are completely outside the scope of this specification.

[[inheritance]]
==== Entity type inheritance

_Inheritance_ is a relationship between entity types.
An entity `X` inherits an entity `Y` if and only if for every type labelled `y` in `Y`, there is a corresponding type labelled `y` in `X` and either:

- the two types with label `y` are identical, or
- the type labelled `y` in `Y` is an entity type `T`, the type labelled `y` in `X` is an entity type `S`, and `S` inherits `T`.

Thus, there is a simple mapping from records of type `X` to records of type `Y`.
Given a record _r_ of type `X`, the _restriction_ of _r_ to a type `Y` inherited by `X` is a structure _s_ containing an element labelled `y` for each type with label `y` occurring in the type `Y`:

- If the type of the element _e_ of `X` with label `y` is identical to the type with label `y` in `Y`, then _s_ contains _e_ labelled `y`.
- Otherwise, the type of the element _e_ of `X` must be an entity type `S`, the type with the label `y` in `Y` must be an entity type `T`, and `S` must inherit `T`.
Then _s_ contains the restriction of _e_ to `T`, labelled `y`.

Then _s_ is a record of type `Y`.

Any well-defined operation on records of type `Y` is also a well-defined operation on the restriction of a record to `Y`.
We therefore adopt the principle that an operation which may be applied to a record of a given entity type may also be applied to a record of any entity type which inherits the first entity type.

=== Circularity

Our definitions above are intended to be descriptive rather than constructive.
It's not, in general, possible to construct an arbitrary record in a finite number of steps by beginning with atomic values and then recursively constructing structures and collections.

The reason for this is that the graph representing a record is not, in general, a finite tree.
The representation of a record as a tree might necessarily be infinite, with a nonterminating cycle involving two or more structures.

=== Databases

A _database_ is a finite set of records.

A given database might be restricted to contain only records belonging to a statically-enumerated list of entities.

[NOTE]
Some databases store records as trees; other databases store them in a flattened _normalized_ form.
Questions about the representation used for record storage are completely outside the scope of this specification.
Such questions are the domain of our sister-specifications.
