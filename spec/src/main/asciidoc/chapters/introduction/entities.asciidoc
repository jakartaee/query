== Type system

This specification assumes that data is represented in a structured form, that is, that it is expressed in terms of:

1. **atomic values**,
2. **collections**, and
3. **structures**.

Any atomic value, collection, or structure belongs to at least one well-defined type.

[[atomic-values]]
=== Atomic values

_Atomic values_ are things defined externally to this specification, taken to include--at bare minimum--strings of Unicode characters, `true` and `false`, integers, floating point numbers, and dates, times, and datetimes.
Every atomic value has a named type, referred to in the sister-specifications of this specification as a _basic type_.

[NOTE]
The atomic value types allowed by an implementation of Jakarta Query depend on the programming language and underlying database technology.

Atomic values of distinct type are never considered identical (equal).
Whether two atomic values of the same type are considered identical depends on semantics which are specific to the type.
For example, two Unicode strings are identical if they have the same length and the same Unicode character at each position.
Identity for a given atomic value type must be reflexive, symmetric, and transitive.

[NOTE]
====
An implementation of this specification in Java typically supports at least the following atomic types: Java primitive types, `String`, `LocalDate`, `LocalDateTime`, `LocalTime`, `Year`, and `Instant`, `java.util.UUID`, `java.math.BigInteger` and `java.math.BigDecimal`, `byte[]`, and  `enum` types.
====

An atomic value might be _null_.
Null values are conventionally used to represent missing or unknown information.footnote:[The null value is also indispensable when evaluating <<path-expressions,path expressions>> in queries involving <<left-joins,left joins>> and when evaluating <<treat,treated path expressions>>.]
A null value is considered distinct from and distinguishable from every non-null value of the same type.
The relationship between distinctness in this sense and <<equality-and-inequality,equality>> is not defined by this specification, and the behavior of some expressions involving null values varies between implementations of Jakarta Query.

[NOTE]
====
An implementation of Jakarta Query is permitted to treat null values as equal, so that, in the sense defined by <<predicates>>, the <<equality-and-inequality,comparison expression>> `null = null` is satisfied while `null <> null` is unsatisfied.
Such implementations are typically based on binary logic.
On the other hand, an implementation is permitted to treat null values as unequal, so that both `null = null` and `null <> null` are unsatisfied.
Such implementations are typically based on SQL-style ternary logic.
Jakarta Persistence requires the use of ternary logic and treats null values as unequal.
Jakarta Data permits either treatment.
====

[[collections]]
=== Collections

A _collection_ is a finite set, list, or map containing atomic values or structures.
A collection might contain atomic values, or it might contain structures.
The keys of a map must be atomic values.

Collections are homogeneous.
A collection may not contain both atomic values and structures.

- If a collection contains atomic values, then every atomic value has the same type.
- If a collection contains structures, then every structure has the same type.
- As an exception to the previous rule, a collection may contain structures belonging to distinct <<entities-and-embeddables,entity types>> if there is some entity type which is <<inheritance,inherited>> by the type of every structure contained in the collection.
- Every key of a map has the same atomic value type.

A collection therefore has a type derived from the type of the atomic values or structures it contains--and, for a map, from the type of its keys.
We consider that two collections have the same type if they contain the same type of atomic value or structure.
For a map, we also require that they have the same type of key.

A collection has no identity independent of the values it contains.

- Two sets are identical if they contain exactly the same elements.
- Two lists are identical if they contain exactly the same elements at exactly the same positions.
- Two maps are identical if they contain exactly the same keys, and identical values for each key.

As usual:

- A set never contains two identical elements; a map never contains two identical keys.
- On the other hand, a list may contain identical elements at different positions within the listfootnote:[When discussing query result lists, we sometimes say that identical elements belonging to a list are _duplicates_.]; a map may contain identical values when their keys are non-identical.

[[structures-and-records]]
=== Structures and records

A _structure_ is a finite set of labeled elements, each of which is an atomic value, a nested structure, or a collection.

Structures are inhomogeneous.
Elements with distinct labels may have distinct types.

Every structure has a type derived from the types of its elements.
We consider that two structures have the same type if:

- they contain the same labels, and
- for each label, the labeled elements have the same type.

A structure has no identity independent of the labeled elements it contains.
Two structures are identical if they contain exactly the same labels, and identical atomic values, collections, or nested structures for each label.

For example--borrowing a convenient notation--the following structure might represent a book:

[source,json]
----
{
  isbn: "1-85723-235-6",
  title: "Feersum Endjinn",
  pages: 279,
  year: 1994,
  authors: [
    {
      name: "Iain M. Banks",
      born: 'February 16, 1954',
      died: 'June 9, 2013'
    }
  ]
}
----

A _record_ is a special kind of structure.
Every record must have an _identifier_ which uniquely distinguishes it from other structures with the same type.
The identifier must be a subset of the labeled elements of the structure.

For example, `{ isbn: "1-85723-235-6" }` might be an identifier of the structure given above.

[[entities-and-embeddables]]
=== Entities and embeddable types

A structure type might be assigned a static name.footnote:[That is, the name is assigned to the type before the program using Jakarta Query is compiled and executed.]

- An _embeddable type_ is an assignment of a name to a given type of structure.
  For example, we might assign the name `Author` to the type of the structure:

    {
      name: "Iain M. Banks",
      born: 'February 16, 1954',
      died: 'June 9, 2013'
    }

- An _entity_ (or _entity type_) is an assignment of a name to a given type of record.
For example, we might assign the name `Book` to the type of the record given in the example above.

The name must be a legal Java identifier.
That is, it must be a string of letters and digits, along with the characters `\_` and `$`, and must begin with a letter or with `_`.footnote:[Use of `_` or `$` in the name of an entity is discouraged.]

It follows from this definition that we may express:

- an embeddable type as a set of labels, together with their types,
- an entity as a set of labels, together with their types, and whether they belong to the record identifier.

For example:

[source]
----
Author :=
{
    name: String,
    born: LocalDate,
    died: LocalDate
}

Book :=
{
  isbn: @Id String,
  title: String,
  pages: Integer,
  year: Integer,
  authors: Set<Author>
}
----

A record with the same type as an entity type is said to be an _instance_ (or _instantiation_) of the entity.
Similarly, a structure with the same type as an embeddable type is said to be an instance of the embeddable type.
footnote:[In some implementations, it might be possible to assign multiple names to a single structure type, and then a given instance of that type might be considered to belong to just one of the named entity or embeddable types. We do not address this wrinkle here, since implementations of Jakarta Query are not required to allow this.]

An entity is directly addressable in a query.
An atomic value type, a collection type, or a structure type which is not an entity is not directly addressable, and must be addressed indirectly via an entity.

[NOTE]
Some database technologies are capable of storing an arbitrary structure whose type is not known at compile time.
Other technologies require that the structure belong to a defined entity or embeddable type.
Independent of the database technology itself, an implementation of Jakarta Query might require that structure types be named, or might offer a way to encode and store generic structures.
Implementations of Jakarta Query are not required to support storage of such generic structures.

[NOTE]
The name of an entity might be involved in mapping an association between a type defined in a programming language (for example, a Java class) and an area of storage in the database (for example, a table).
Such mappings are completely outside the scope of this specification.

[[inheritance]]
==== Entity type inheritance

_Inheritance_ is a relationship between entity types.
An entity `X` inherits an entity `Y` if and only if for every type labeled `y` in `Y`, there is a corresponding type labeled `y` in `X` and either:

- the two types with label `y` are identical, or
- the type labeled `y` in `Y` is an entity type `T`, the type labeled `y` in `X` is an entity type `S`, and `S` inherits `T`.

Thus, there is a simple mapping from records of type `X` to records of type `Y`.
Given a record _r_ of type `X`, the _restriction_ of _r_ to a type `Y` inherited by `X` is a structure _s_ containing an element labeled `y` for each type with label `y` occurring in the type `Y`:

- If the type of the element _e_ of `X` with label `y` is identical to the type with label `y` in `Y`, then _s_ contains _e_ labeled `y`.
- Otherwise, the type of the element _e_ of `X` must be an entity type `S`, the type with the label `y` in `Y` must be an entity type `T`, and `S` must inherit `T`.
Then _s_ contains the restriction of _e_ to `T`, labeled `y`.

Then _s_ is a record of type `Y`.

Any well-defined operation on records of type `Y` is also a well-defined operation on the restriction of a record to `Y`.
We therefore adopt the principle that an operation which may be applied to a record of a given entity type may also be applied to a record of any entity type which inherits the first entity type.

[[circularity]]
=== Circularity

Our definitions above are intended to be descriptive rather than constructive.
It's not, in general, possible to construct an arbitrary record in a finite number of steps by beginning with atomic values and then recursively constructing structures and collections.

The reason for this is that the graph representing a record is not, in general, a finite tree.
The representation of a record as a tree might necessarily be infinite, with a nonterminating cycle involving two or more structures.

On the other hand, any record is assumed to be representable as a finite directed graph.

[NOTE]
====
Circularity typically arises in implementations which support _associations_ between entity types.
An association is a labeled element of an entity or embeddable type which is itself an entity type.
This specification does not require that implementations allow associations between entities, and the core language does not feature constructs for querying associations.
In particular, an implementation of Jakarta Query which targets a non-relational database might not feature any support for associations.
On the other hand, the extended language defines constructs like <<joins-nested,joins>> and <<treat,typecasts>> which are intended for use in implementations which do support associations.
In particular, association mapping is a fundamental feature of Jakarta Persistence, and circularity is completely normal in implementations based on object/relational mapping.
====

=== Databases

A _database_ is a finite set of records.

A given database might be restricted to contain only records belonging to a statically-enumerated list of entities.

[NOTE]
Some databases store records as trees; other databases store them in a flattened _normalized_ form.
In some databases, records must be disjoint; in other databases, one record might be nested inside another record.
Questions about the representation used for record storage are completely outside the scope of this specification.
Such questions are the domain of our sister-specifications.

[[mapping-to-java]]
=== Mapping to Java

When Jakarta Query is used from within the Java programming language:

- An entity or embeddable type typically corresponds to a Java class or record type, and the labeled elements of an entity or embeddable typically correspond to fields or properties of the class or record type.
- An atomic value type typically corresponds to a Java primitive type, class, or enumerated type.
- Every <<value-expressions,value expression>> in a query is assigned a Java type. Conceptually -- but not literally -- the expression evaluates to a (possibly null) instance of that type.

The interpretation of an <<operator-expressions,operator expression>> or <<literal-expressions,literal expression>> of a given type is given by the interpretation of the equivalent expression in Java.
However, the precise behavior of some queries might vary depending on the native semantics of queries on the underlying datastore. For example, numeric precision and overflow, string collation, and integer division are permitted to depart from the semantics of the Java language.

[NOTE]
====
This specification should not be interpreted to mandate an inefficient implementation of query language constructs in cases where the native behavior of the database varies from Java in such minor ways. That said, portability between implementations of Jakarta Query is maximized when their behavior is closest to the Java language.
====

[[paths]]
=== Paths

Consider an arbitrary root structure constructed recursively using only atomic values and structures (and no collections).
Such a structure may be viewed as a directed tree, where vertices are structures and atomic values, and edges are labeled structure elements.
Then it is possible to uniquely assign a compound label to any given element of any structure in the tree by:

1. tracing a directed path from the given element to the root structure, and
2. collecting the labels of each element visited along the path.

Conventionally, we write such a compound label in reverse order, beginning with the label of the element belonging to the root structure and ending with the label of the most nested element, and we separate labels with periods.

For example, given the structure:

[source,json]
----
{
    author: {
        name: "Iain M. Banks",
        born: {
            day: 16, month: { name: 'February', number: 2 }, year: 1954
        },
        died: {
            day: 9, month: { name: 'June', number: 6 }, year: 2013
        }
    }
}
----

The compound label `author.born.month.name` refers to the element `name: 'February'`.

It is not possible to uniquely assign compound labels to every element belonging to an arbitrary structure, since:

- a generic structure contains sets, whose elements cannot be assigned labelsfootnote:[It would be possible, of course, to assign labels to elements of a list or map.], and
- as discussed above in <<circularity>>, a database is not required to contain only trees.

However, we may use such labelling within any subtree that does not contain a collection, though in principle the compound labels might not be unique.